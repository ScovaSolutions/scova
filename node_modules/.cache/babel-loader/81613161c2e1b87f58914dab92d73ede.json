{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport { decorate } from './private/utils';\n\nfunction toObject(cache, value) {\n  if (value === Object(value)) {\n    return value;\n  }\n\n  return cache[value] || (cache[value] = {});\n}\n\nfunction applyAndCache(context, fn, args, cache, signature) {\n  var ret = fn.apply(context, args);\n  cache[signature] = ret;\n  return ret;\n}\n\nfunction metaForDescriptor(descriptor) {\n  var fn = void 0,\n      wrapKey = void 0; // This is ugly code, but way faster than other\n  // ways I tried that *looked* pretty\n\n  if (descriptor.value) {\n    fn = descriptor.value;\n    wrapKey = 'value';\n  } else if (descriptor.get) {\n    fn = descriptor.get;\n    wrapKey = 'get';\n  } else if (descriptor.set) {\n    fn = descriptor.set;\n    wrapKey = 'set';\n  }\n\n  return {\n    fn: fn,\n    wrapKey: wrapKey\n  };\n}\n\nfunction handleDescriptor(target, key, descriptor) {\n  console.warn('DEPRECATION: @memoize is deprecated and will be removed shortly. Use @decorate with lodash\\'s memoize helper.\\n\\n  https://github.com/jayphelps/core-decorators.js#decorate');\n\n  var _metaForDescriptor = metaForDescriptor(descriptor),\n      fn = _metaForDescriptor.fn,\n      wrapKey = _metaForDescriptor.wrapKey;\n\n  var argumentCache = new WeakMap();\n  var signatureCache = Object.create(null);\n  var primativeRefCache = Object.create(null);\n  var argumentIdCounter = 0;\n  return _extends({}, descriptor, _defineProperty({}, wrapKey, function memoizeWrapper() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var signature = '0';\n\n    for (var i = 0, l = args.length; i < l; i++) {\n      var arg = args[i];\n      var argRef = toObject(primativeRefCache, arg);\n      var argKey = argumentCache.get(argRef);\n\n      if (argKey === undefined) {\n        argKey = ++argumentIdCounter;\n        argumentCache.set(argRef, argKey);\n      }\n\n      signature += argKey;\n    }\n\n    return signatureCache[signature] || applyAndCache(this, fn, arguments, signatureCache, signature);\n  }));\n}\n\nexport default function memoize() {\n  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  return decorate(handleDescriptor, args);\n}","map":{"version":3,"sources":["/Users/anhad/Development/scova-org/node_modules/core-decorators/es/memoize.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","_defineProperty","obj","value","defineProperty","enumerable","configurable","writable","decorate","toObject","cache","applyAndCache","context","fn","args","signature","ret","apply","metaForDescriptor","descriptor","wrapKey","get","set","handleDescriptor","console","warn","_metaForDescriptor","argumentCache","WeakMap","signatureCache","create","primativeRefCache","argumentIdCounter","memoizeWrapper","_len","Array","_key","l","arg","argRef","argKey","undefined","memoize","_len2","_key2"],"mappings":"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","sourcesContent":["var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { decorate } from './private/utils';\n\nfunction toObject(cache, value) {\n  if (value === Object(value)) {\n    return value;\n  }\n  return cache[value] || (cache[value] = {});\n}\n\nfunction applyAndCache(context, fn, args, cache, signature) {\n  var ret = fn.apply(context, args);\n  cache[signature] = ret;\n  return ret;\n}\n\nfunction metaForDescriptor(descriptor) {\n  var fn = void 0,\n      wrapKey = void 0;\n\n  // This is ugly code, but way faster than other\n  // ways I tried that *looked* pretty\n\n  if (descriptor.value) {\n    fn = descriptor.value;\n    wrapKey = 'value';\n  } else if (descriptor.get) {\n    fn = descriptor.get;\n    wrapKey = 'get';\n  } else if (descriptor.set) {\n    fn = descriptor.set;\n    wrapKey = 'set';\n  }\n\n  return { fn: fn, wrapKey: wrapKey };\n}\n\nfunction handleDescriptor(target, key, descriptor) {\n  console.warn('DEPRECATION: @memoize is deprecated and will be removed shortly. Use @decorate with lodash\\'s memoize helper.\\n\\n  https://github.com/jayphelps/core-decorators.js#decorate');\n\n  var _metaForDescriptor = metaForDescriptor(descriptor),\n      fn = _metaForDescriptor.fn,\n      wrapKey = _metaForDescriptor.wrapKey;\n\n  var argumentCache = new WeakMap();\n  var signatureCache = Object.create(null);\n  var primativeRefCache = Object.create(null);\n  var argumentIdCounter = 0;\n\n  return _extends({}, descriptor, _defineProperty({}, wrapKey, function memoizeWrapper() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var signature = '0';\n\n    for (var i = 0, l = args.length; i < l; i++) {\n      var arg = args[i];\n      var argRef = toObject(primativeRefCache, arg);\n      var argKey = argumentCache.get(argRef);\n\n      if (argKey === undefined) {\n        argKey = ++argumentIdCounter;\n        argumentCache.set(argRef, argKey);\n      }\n\n      signature += argKey;\n    }\n\n    return signatureCache[signature] || applyAndCache(this, fn, arguments, signatureCache, signature);\n  }));\n}\n\nexport default function memoize() {\n  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  return decorate(handleDescriptor, args);\n}"]},"metadata":{},"sourceType":"module"}